- to_grid_index ok that it returns VectorX<usize>, or should it return Result<VectorX<usize>> because values might not fit in usize?
- Optimization in `DynamicStorage2D`: Implement `cmp` by doing a bitwise comparison instead of cell-by-cell. This requires that we implement `Bits` for `[u8]`, which might be a bit tricky
- Further generalization between 2D and 3D storages. The `FixedDepthStorageND` types can be implemented both for 2D and 3D with basically the same implementation, the only thing that is different is the dimensionality, which we need as a number constant on the `Dimension` type
    - Make a `FixedDepthStorage` trait and implement `Storage<D: Dimension>` for any type that implements `FixedDepthStorage`
    - `FixedDepthStorage` needs only a `const MAX_LEVELS: usize` and `const DIMENSIONALITY: usize`
    - Then we can impement `FixedDepthStorage` very easily for `FixedDepthStorage2D`, `FixedDepthStorage3D`
    - Maybe even have a generic `FixedDepthStorageND<Dimension, BitType>` struct?
- Add a `ancestor` or `with_depth` method to variable-width Morton indices
- Add a `VariableDepthMortonIndex` trait that supports `parent`, `child(cell)`, and `ancestor(depth)`
    - Generalize `child(cell)` to `descendant(iter<cell>)`?